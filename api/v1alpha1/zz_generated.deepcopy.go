// Code generated by hand for early scaffolding; replace with controller-gen when ready.
//
// In Phase 1 we primarily need DeepCopy implementations so controller-runtime
// can work with typed objects once reconcilers migrate from unstructured.

package v1alpha1

import (
	"k8s.io/apimachinery/pkg/runtime"
)

func (in *ZPoolVdevSpec) DeepCopyInto(out *ZPoolVdevSpec) {
	*out = *in
	if in.Devices != nil {
		out.Devices = make([]string, len(in.Devices))
		copy(out.Devices, in.Devices)
	}
}

func (in *ZPoolVdevSpec) DeepCopy() *ZPoolVdevSpec {
	if in == nil {
		return nil
	}
	out := new(ZPoolVdevSpec)
	in.DeepCopyInto(out)
	return out
}

func (in *ZPoolSpec) DeepCopyInto(out *ZPoolSpec) {
	*out = *in
	if in.Vdevs != nil {
		out.Vdevs = make([]ZPoolVdevSpec, len(in.Vdevs))
		for i := range in.Vdevs {
			in.Vdevs[i].DeepCopyInto(&out.Vdevs[i])
		}
	}
}

func (in *ZPoolSpec) DeepCopy() *ZPoolSpec {
	if in == nil {
		return nil
	}
	out := new(ZPoolSpec)
	in.DeepCopyInto(out)
	return out
}

func (in *ZPool) DeepCopyInto(out *ZPool) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	out.Status = in.Status
}

func (in *ZPool) DeepCopy() *ZPool {
	if in == nil {
		return nil
	}
	out := new(ZPool)
	in.DeepCopyInto(out)
	return out
}

func (in *ZPool) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

func (in *ZPoolList) DeepCopyInto(out *ZPoolList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		out.Items = make([]ZPool, len(in.Items))
		for i := range in.Items {
			in.Items[i].DeepCopyInto(&out.Items[i])
		}
	}
}

func (in *ZPoolList) DeepCopy() *ZPoolList {
	if in == nil {
		return nil
	}
	out := new(ZPoolList)
	in.DeepCopyInto(out)
	return out
}

func (in *ZPoolList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

func (in *ZDatasetSpec) DeepCopyInto(out *ZDatasetSpec) {
	*out = *in
	if in.Properties != nil {
		out.Properties = make(map[string]string, len(in.Properties))
		for k, v := range in.Properties {
			out.Properties[k] = v
		}
	}
}

func (in *ZDatasetSpec) DeepCopy() *ZDatasetSpec {
	if in == nil {
		return nil
	}
	out := new(ZDatasetSpec)
	in.DeepCopyInto(out)
	return out
}

func (in *ZDatasetStatus) DeepCopyInto(out *ZDatasetStatus) {
	*out = *in
}

func (in *ZDatasetStatus) DeepCopy() *ZDatasetStatus {
	if in == nil {
		return nil
	}
	out := new(ZDatasetStatus)
	in.DeepCopyInto(out)
	return out
}

func (in *ZDataset) DeepCopyInto(out *ZDataset) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

func (in *ZDataset) DeepCopy() *ZDataset {
	if in == nil {
		return nil
	}
	out := new(ZDataset)
	in.DeepCopyInto(out)
	return out
}

func (in *ZDataset) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

func (in *ZDatasetList) DeepCopyInto(out *ZDatasetList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		out.Items = make([]ZDataset, len(in.Items))
		for i := range in.Items {
			in.Items[i].DeepCopyInto(&out.Items[i])
		}
	}
}

func (in *ZDatasetList) DeepCopy() *ZDatasetList {
	if in == nil {
		return nil
	}
	out := new(ZDatasetList)
	in.DeepCopyInto(out)
	return out
}

func (in *ZDatasetList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

func (in *ZSnapshotSpec) DeepCopyInto(out *ZSnapshotSpec) { *out = *in }

func (in *ZSnapshotSpec) DeepCopy() *ZSnapshotSpec {
	if in == nil {
		return nil
	}
	out := new(ZSnapshotSpec)
	in.DeepCopyInto(out)
	return out
}

func (in *ZSnapshotStatus) DeepCopyInto(out *ZSnapshotStatus) { *out = *in }

func (in *ZSnapshotStatus) DeepCopy() *ZSnapshotStatus {
	if in == nil {
		return nil
	}
	out := new(ZSnapshotStatus)
	in.DeepCopyInto(out)
	return out
}

func (in *ZSnapshot) DeepCopyInto(out *ZSnapshot) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

func (in *ZSnapshot) DeepCopy() *ZSnapshot {
	if in == nil {
		return nil
	}
	out := new(ZSnapshot)
	in.DeepCopyInto(out)
	return out
}

func (in *ZSnapshot) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

func (in *ZSnapshotList) DeepCopyInto(out *ZSnapshotList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		out.Items = make([]ZSnapshot, len(in.Items))
		for i := range in.Items {
			in.Items[i].DeepCopyInto(&out.Items[i])
		}
	}
}

func (in *ZSnapshotList) DeepCopy() *ZSnapshotList {
	if in == nil {
		return nil
	}
	out := new(ZSnapshotList)
	in.DeepCopyInto(out)
	return out
}

func (in *ZSnapshotList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

func (in *SMBShareSecretRef) DeepCopyInto(out *SMBShareSecretRef) { *out = *in }

func (in *SMBShareSecretRef) DeepCopy() *SMBShareSecretRef {
	if in == nil {
		return nil
	}
	out := new(SMBShareSecretRef)
	in.DeepCopyInto(out)
	return out
}

func (in *SMBShareUser) DeepCopyInto(out *SMBShareUser) {
	*out = *in
	in.PasswordSecretRef.DeepCopyInto(&out.PasswordSecretRef)
}

func (in *SMBShareUser) DeepCopy() *SMBShareUser {
	if in == nil {
		return nil
	}
	out := new(SMBShareUser)
	in.DeepCopyInto(out)
	return out
}

func (in *SMBShareSpec) DeepCopyInto(out *SMBShareSpec) {
	*out = *in
	if in.Users != nil {
		out.Users = make([]SMBShareUser, len(in.Users))
		for i := range in.Users {
			in.Users[i].DeepCopyInto(&out.Users[i])
		}
	}
	if in.Options != nil {
		out.Options = runtime.DeepCopyJSON(in.Options)
	}
}

func (in *SMBShareSpec) DeepCopy() *SMBShareSpec {
	if in == nil {
		return nil
	}
	out := new(SMBShareSpec)
	in.DeepCopyInto(out)
	return out
}

func (in *SMBShareStatus) DeepCopyInto(out *SMBShareStatus) { *out = *in }

func (in *SMBShareStatus) DeepCopy() *SMBShareStatus {
	if in == nil {
		return nil
	}
	out := new(SMBShareStatus)
	in.DeepCopyInto(out)
	return out
}

func (in *SMBShare) DeepCopyInto(out *SMBShare) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

func (in *SMBShare) DeepCopy() *SMBShare {
	if in == nil {
		return nil
	}
	out := new(SMBShare)
	in.DeepCopyInto(out)
	return out
}

func (in *SMBShare) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

func (in *SMBShareList) DeepCopyInto(out *SMBShareList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		out.Items = make([]SMBShare, len(in.Items))
		for i := range in.Items {
			in.Items[i].DeepCopyInto(&out.Items[i])
		}
	}
}

func (in *SMBShareList) DeepCopy() *SMBShareList {
	if in == nil {
		return nil
	}
	out := new(SMBShareList)
	in.DeepCopyInto(out)
	return out
}

func (in *SMBShareList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

func (in *ZSnapshotScheduleRetention) DeepCopyInto(out *ZSnapshotScheduleRetention) { *out = *in }

func (in *ZSnapshotScheduleRetention) DeepCopy() *ZSnapshotScheduleRetention {
	if in == nil {
		return nil
	}
	out := new(ZSnapshotScheduleRetention)
	in.DeepCopyInto(out)
	return out
}

func (in *ZSnapshotScheduleSpec) DeepCopyInto(out *ZSnapshotScheduleSpec) {
	*out = *in
	if in.Retention != nil {
		out.Retention = new(ZSnapshotScheduleRetention)
		in.Retention.DeepCopyInto(out.Retention)
	}
}

func (in *ZSnapshotScheduleSpec) DeepCopy() *ZSnapshotScheduleSpec {
	if in == nil {
		return nil
	}
	out := new(ZSnapshotScheduleSpec)
	in.DeepCopyInto(out)
	return out
}

func (in *ZSnapshotScheduleStatus) DeepCopyInto(out *ZSnapshotScheduleStatus) { *out = *in }

func (in *ZSnapshotScheduleStatus) DeepCopy() *ZSnapshotScheduleStatus {
	if in == nil {
		return nil
	}
	out := new(ZSnapshotScheduleStatus)
	in.DeepCopyInto(out)
	return out
}

func (in *ZSnapshotSchedule) DeepCopyInto(out *ZSnapshotSchedule) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

func (in *ZSnapshotSchedule) DeepCopy() *ZSnapshotSchedule {
	if in == nil {
		return nil
	}
	out := new(ZSnapshotSchedule)
	in.DeepCopyInto(out)
	return out
}

func (in *ZSnapshotSchedule) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

func (in *ZSnapshotScheduleList) DeepCopyInto(out *ZSnapshotScheduleList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		out.Items = make([]ZSnapshotSchedule, len(in.Items))
		for i := range in.Items {
			in.Items[i].DeepCopyInto(&out.Items[i])
		}
	}
}

func (in *ZSnapshotScheduleList) DeepCopy() *ZSnapshotScheduleList {
	if in == nil {
		return nil
	}
	out := new(ZSnapshotScheduleList)
	in.DeepCopyInto(out)
	return out
}

func (in *ZSnapshotScheduleList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

func (in *ZSnapshotRestoreSpec) DeepCopyInto(out *ZSnapshotRestoreSpec) {
	*out = *in
	if in.AccessModes != nil {
		out.AccessModes = make([]string, len(in.AccessModes))
		copy(out.AccessModes, in.AccessModes)
	}
	if in.Resources != nil {
		out.Resources = runtime.DeepCopyJSON(in.Resources)
	}
}

func (in *ZSnapshotRestoreSpec) DeepCopy() *ZSnapshotRestoreSpec {
	if in == nil {
		return nil
	}
	out := new(ZSnapshotRestoreSpec)
	in.DeepCopyInto(out)
	return out
}

func (in *ZSnapshotRestoreStatus) DeepCopyInto(out *ZSnapshotRestoreStatus) { *out = *in }

func (in *ZSnapshotRestoreStatus) DeepCopy() *ZSnapshotRestoreStatus {
	if in == nil {
		return nil
	}
	out := new(ZSnapshotRestoreStatus)
	in.DeepCopyInto(out)
	return out
}

func (in *ZSnapshotRestore) DeepCopyInto(out *ZSnapshotRestore) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

func (in *ZSnapshotRestore) DeepCopy() *ZSnapshotRestore {
	if in == nil {
		return nil
	}
	out := new(ZSnapshotRestore)
	in.DeepCopyInto(out)
	return out
}

func (in *ZSnapshotRestore) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

func (in *ZSnapshotRestoreList) DeepCopyInto(out *ZSnapshotRestoreList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		out.Items = make([]ZSnapshotRestore, len(in.Items))
		for i := range in.Items {
			in.Items[i].DeepCopyInto(&out.Items[i])
		}
	}
}

func (in *ZSnapshotRestoreList) DeepCopy() *ZSnapshotRestoreList {
	if in == nil {
		return nil
	}
	out := new(ZSnapshotRestoreList)
	in.DeepCopyInto(out)
	return out
}

func (in *ZSnapshotRestoreList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

func (in *NASUserSpec) DeepCopyInto(out *NASUserSpec) { *out = *in }

func (in *NASUserSpec) DeepCopy() *NASUserSpec {
	if in == nil {
		return nil
	}
	out := new(NASUserSpec)
	in.DeepCopyInto(out)
	return out
}

func (in *NASUserStatus) DeepCopyInto(out *NASUserStatus) { *out = *in }

func (in *NASUserStatus) DeepCopy() *NASUserStatus {
	if in == nil {
		return nil
	}
	out := new(NASUserStatus)
	in.DeepCopyInto(out)
	return out
}

func (in *NASUser) DeepCopyInto(out *NASUser) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

func (in *NASUser) DeepCopy() *NASUser {
	if in == nil {
		return nil
	}
	out := new(NASUser)
	in.DeepCopyInto(out)
	return out
}

func (in *NASUser) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

func (in *NASUserList) DeepCopyInto(out *NASUserList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		out.Items = make([]NASUser, len(in.Items))
		for i := range in.Items {
			in.Items[i].DeepCopyInto(&out.Items[i])
		}
	}
}

func (in *NASUserList) DeepCopy() *NASUserList {
	if in == nil {
		return nil
	}
	out := new(NASUserList)
	in.DeepCopyInto(out)
	return out
}

func (in *NASUserList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

func (in *NASGroupSpec) DeepCopyInto(out *NASGroupSpec) {
	*out = *in
	if in.Members != nil {
		out.Members = make([]string, len(in.Members))
		copy(out.Members, in.Members)
	}
}

func (in *NASGroupSpec) DeepCopy() *NASGroupSpec {
	if in == nil {
		return nil
	}
	out := new(NASGroupSpec)
	in.DeepCopyInto(out)
	return out
}

func (in *NASGroupStatus) DeepCopyInto(out *NASGroupStatus) { *out = *in }

func (in *NASGroupStatus) DeepCopy() *NASGroupStatus {
	if in == nil {
		return nil
	}
	out := new(NASGroupStatus)
	in.DeepCopyInto(out)
	return out
}

func (in *NASGroup) DeepCopyInto(out *NASGroup) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

func (in *NASGroup) DeepCopy() *NASGroup {
	if in == nil {
		return nil
	}
	out := new(NASGroup)
	in.DeepCopyInto(out)
	return out
}

func (in *NASGroup) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

func (in *NASGroupList) DeepCopyInto(out *NASGroupList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		out.Items = make([]NASGroup, len(in.Items))
		for i := range in.Items {
			in.Items[i].DeepCopyInto(&out.Items[i])
		}
	}
}

func (in *NASGroupList) DeepCopy() *NASGroupList {
	if in == nil {
		return nil
	}
	out := new(NASGroupList)
	in.DeepCopyInto(out)
	return out
}

func (in *NASGroupList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

func (in *NASNFSExport) DeepCopyInto(out *NASNFSExport) {
	*out = *in
	if in.Clients != nil {
		out.Clients = make([]string, len(in.Clients))
		copy(out.Clients, in.Clients)
	}
}

func (in *NASNFSExport) DeepCopy() *NASNFSExport {
	if in == nil {
		return nil
	}
	out := new(NASNFSExport)
	in.DeepCopyInto(out)
	return out
}

func (in *NASShareSpec) DeepCopyInto(out *NASShareSpec) {
	*out = *in
	if in.Users != nil {
		out.Users = make([]string, len(in.Users))
		copy(out.Users, in.Users)
	}
	if in.Options != nil {
		out.Options = make(map[string]any, len(in.Options))
		for k, v := range in.Options {
			out.Options[k] = v
		}
	}
	if in.NFS != nil {
		out.NFS = new(NASNFSExport)
		in.NFS.DeepCopyInto(out.NFS)
	}
}

func (in *NASShareSpec) DeepCopy() *NASShareSpec {
	if in == nil {
		return nil
	}
	out := new(NASShareSpec)
	in.DeepCopyInto(out)
	return out
}

func (in *NASShareStatus) DeepCopyInto(out *NASShareStatus) { *out = *in }

func (in *NASShareStatus) DeepCopy() *NASShareStatus {
	if in == nil {
		return nil
	}
	out := new(NASShareStatus)
	in.DeepCopyInto(out)
	return out
}

func (in *NASShare) DeepCopyInto(out *NASShare) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

func (in *NASShare) DeepCopy() *NASShare {
	if in == nil {
		return nil
	}
	out := new(NASShare)
	in.DeepCopyInto(out)
	return out
}

func (in *NASShare) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

func (in *NASShareList) DeepCopyInto(out *NASShareList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		out.Items = make([]NASShare, len(in.Items))
		for i := range in.Items {
			in.Items[i].DeepCopyInto(&out.Items[i])
		}
	}
}

func (in *NASShareList) DeepCopy() *NASShareList {
	if in == nil {
		return nil
	}
	out := new(NASShareList)
	in.DeepCopyInto(out)
	return out
}

func (in *NASShareList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}
